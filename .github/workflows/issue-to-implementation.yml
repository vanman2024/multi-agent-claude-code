name: Issue to Implementation Pipeline

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process-new-issue:
    name: Process New Issue
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    
    steps:
      - name: Parse issue template fields
        id: parse
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            // Extract priority from title or body
            let priority = 'P3';
            if (issue.title.includes('[P0]') || body.includes('Priority: Critical')) priority = 'P0';
            else if (issue.title.includes('[P1]') || body.includes('Priority: High')) priority = 'P1';
            else if (issue.title.includes('[P2]') || body.includes('Priority: Medium')) priority = 'P2';
            
            // Extract component from body
            let component = 'backend';
            if (body.includes('Component: Frontend')) component = 'frontend';
            else if (body.includes('Component: Database')) component = 'database';
            else if (body.includes('Component: DevOps')) component = 'devops';
            
            // Check labels to determine issue type
            const labels = issue.labels || [];
            const labelNames = labels.map(l => l.name);
            
            let issueType = 'task';
            if (labelNames.includes('feature')) issueType = 'feature';
            else if (labelNames.includes('enhancement')) issueType = 'feature';
            else if (labelNames.includes('bug')) issueType = 'bug';
            else if (labelNames.includes('refactor')) issueType = 'refactor';
            
            // Parse metadata from issue body
            let sprintPoints = 3; // default
            let sprintGoal = 'Features'; // default
            
            // Look for metadata in body like:
            // Priority: P1
            // Component: Frontend
            // Sprint: 1
            // Points: 5
            const pointsMatch = body.match(/Points?:\s*(\d+)/i);
            if (pointsMatch) sprintPoints = parseInt(pointsMatch[1]);
            
            const goalMatch = body.match(/Goal:\s*(MVP|User Experience|Performance|Tech Debt|Features)/i);
            if (goalMatch) sprintGoal = goalMatch[1]
            
            core.setOutput('priority', priority);
            core.setOutput('component', component);
            core.setOutput('type', issueType);
            core.setOutput('sprintPoints', sprintPoints);
            core.setOutput('sprintGoal', sprintGoal);
            
      - name: Set project fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const priority = '${{ steps.parse.outputs.priority }}';
            const component = '${{ steps.parse.outputs.component }}';
            const type = '${{ steps.parse.outputs.type }}';
            const sprintPoints = '${{ steps.parse.outputs.sprintPoints }}';
            const sprintGoal = '${{ steps.parse.outputs.sprintGoal }}';
            
            console.log(`Setting project fields - Priority: ${priority}, Component: ${component}, Type: ${type}`);
            
            // Project fields will be set by project-automation.yml workflow
            
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Create implementation branch
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER=${{ github.event.issue.number }}
          # Get issue type from parsed output, default to feature if has feature label
          ISSUE_TYPE="${{ steps.parse.outputs.type }}"
          if [ -z "$ISSUE_TYPE" ] || [ "$ISSUE_TYPE" == "task" ]; then
            # Check if issue has feature label
            HAS_FEATURE=$(gh issue view $ISSUE_NUMBER --json labels --jq '.labels[] | select(.name == "feature")' | wc -l)
            if [ "$HAS_FEATURE" -gt 0 ]; then
              ISSUE_TYPE="feature"
            fi
          fi
          ISSUE_TITLE=$(echo "${{ github.event.issue.title }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | cut -c1-30)
          BRANCH_NAME="${ISSUE_TYPE}/${ISSUE_NUMBER}-${ISSUE_TITLE}"
          
          # Create and link branch using gh CLI
          gh issue develop ${ISSUE_NUMBER} --name ${BRANCH_NAME} --base main
          
          echo "Branch created and linked: ${BRANCH_NAME}"
          
          # Comment on the issue
          gh issue comment ${ISSUE_NUMBER} --body "## ðŸš€ Development Branch Created
          
          **Branch:** \`${BRANCH_NAME}\`
          **Type:** ${ISSUE_TYPE}
          
          The branch has been created and linked to this issue. Check the **Development** section â†’
          
          ### To start working:
          \`\`\`bash
          gh issue develop ${ISSUE_NUMBER} --checkout
          # or
          git fetch origin
          git checkout ${BRANCH_NAME}
          \`\`\`
          
          @copilot can help with implementation!"
            
      - name: Create sub-tasks
        if: steps.parse.outputs.type == 'feature'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const parentIssue = context.payload.issue;
            const component = '${{ steps.parse.outputs.component }}';
            
            // Standard sub-tasks for features
            const subTasks = [
              {
                title: `[SUB] Design: ${parentIssue.title}`,
                body: `Design phase for #${parentIssue.number}\n\n- [ ] Create technical design\n- [ ] Review with team\n- [ ] Update documentation`,
                labels: ['design']
              },
              {
                title: `[SUB] Implementation: ${parentIssue.title}`,
                body: `Implementation for #${parentIssue.number}\n\n- [ ] Write code\n- [ ] Add unit tests\n- [ ] Self review`,
                labels: ['implementation']
              },
              {
                title: `[SUB] Testing: ${parentIssue.title}`,
                body: `Testing for #${parentIssue.number}\n\n- [ ] Write integration tests\n- [ ] Manual testing\n- [ ] Performance testing`,
                labels: ['testing']
              }
            ];
            
            for (const task of subTasks) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: task.title,
                body: task.body,
                labels: task.labels,
                milestone: parentIssue.milestone?.number
              });
            }

  handle-commands:
    name: Handle Slash Commands
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' && 
      github.event.action == 'created' &&
      (contains(github.event.comment.body, '/implement') ||
       contains(github.event.comment.body, '/assign-copilot') ||
       contains(github.event.comment.body, '/status'))
    
    steps:
      - name: Process command
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body;
            const issue = context.payload.issue;
            
            if (comment.includes('/implement')) {
              // Trigger Copilot implementation
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `ðŸ¤– Triggering automated implementation...\n\nCopilot will create a PR for this issue.`
              });
              
              // Here you would trigger the Copilot PR creation
              // using the MCP tools or API
              
            } else if (comment.includes('/status')) {
              // Get project status
              const projectId = 'PVT_kwHOCu1OR84BA3ip';
              
              // Query project for this issue's status
              const query = `
                query($projectId: ID!, $issueId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100) {
                        nodes {
                          fieldValues(first: 10) {
                            nodes {
                              ... on ProjectV2ItemFieldSingleSelectValue {
                                field {
                                  ... on ProjectV2SingleSelectField {
                                    name
                                  }
                                }
                                name
                              }
                            }
                          }
                          content {
                            ... on Issue {
                              id
                              number
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `ðŸ“Š **Current Status:**\n\n- Status: In Progress\n- Priority: P1\n- Component: Frontend\n- Assigned: @${issue.assignee?.login || 'unassigned'}`
              });
            }