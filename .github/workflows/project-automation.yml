name: Project Board Automation

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, closed, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to add to project'
        required: false

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  PROJECT_ID: PVT_kwHOCu1OR84BA3ip  # Multi-Agent Claude Code Development
  PROJECT_NUMBER: 11
  
  # Field IDs from our project
  STATUS_FIELD: PVTSSF_lAHOCu1OR84BA3ipzgziw9A
  PRIORITY_FIELD: PVTSSF_lAHOCu1OR84BA3ipzgzixBc
  COMPONENT_FIELD: PVTSSF_lAHOCu1OR84BA3ipzgzixC0
  
  # Status option IDs
  STATUS_TODO: f75ad846
  STATUS_IN_PROGRESS: 47fc9ee4
  STATUS_DONE: 98236657
  
  # Priority option IDs
  PRIORITY_P0: 272850f8
  PRIORITY_P1: 257f709e
  PRIORITY_P2: 5041f9b5
  PRIORITY_P3: e6ae2685
  
  # Component option IDs (we only have 4 currently, will add more as needed)
  COMPONENT_FRONTEND: 83954b68
  COMPONENT_BACKEND: 8aa84839
  COMPONENT_DATABASE: eea4cd61
  COMPONENT_DEVOPS: 82f4b58a
  # Additional components to be added to project:
  # API, Authentication, Testing, Documentation, Security, 
  # Performance, Monitoring, Analytics, Payments, Messaging,
  # Search, Storage, CDN, ML/AI, Mobile, Desktop

jobs:
  add-to-project:
    name: Add Issue to Project
    runs-on: ubuntu-latest
    if: (github.event.issue && github.event.action == 'opened') || github.event_name == 'workflow_dispatch'
    outputs:
      item-id: ${{ steps.add-to-project.outputs.itemId }}
    
    steps:
      - name: Add to project
        id: add-to-project
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: https://github.com/users/${{ github.repository_owner }}/projects/${{ env.PROJECT_NUMBER }}
          github-token: ${{ secrets.PROJECT_TOKEN }}
          
      - name: Get item ID
        id: get-item
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const query = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                            number
                          }
                          ... on PullRequest {
                            id
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            // Only add issues, not pull requests
            if (!context.payload.issue) {
              console.log('Not an issue, skipping project addition');
              return;
            }
            const contentId = context.payload.issue.node_id;
            const variables = {
              projectId: process.env.PROJECT_ID
            };
            
            const result = await github.graphql(query, variables);
            const item = result.node.items.nodes.find(i => i.content?.id === contentId);
            
            if (item) {
              core.setOutput('itemId', item.id);
              console.log(`Found item ID: ${item.id}`);
            }
            
  set-fields:
    name: Set Project Fields
    runs-on: ubuntu-latest
    needs: add-to-project
    if: needs.add-to-project.outputs.item-id
    
    steps:
      - name: Set Priority based on labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const itemId = '${{ needs.add-to-project.outputs.item-id }}';
            const labels = context.payload.issue?.labels || context.payload.pull_request?.labels || [];
            
            let priorityId = process.env.PRIORITY_P3; // default
            
            // Check labels for priority indicators
            if (labels.some(l => l.name === 'critical' || l.name === 'urgent')) {
              priorityId = process.env.PRIORITY_P0;
            } else if (labels.some(l => l.name === 'high-priority')) {
              priorityId = process.env.PRIORITY_P1;
            } else {
              priorityId = process.env.PRIORITY_P3; // Default to P3
            }
            
            // Check title for priority indicators
            const title = context.payload.issue?.title || context.payload.pull_request?.title || '';
            if (title.includes('[P0]') || title.includes('[CRITICAL]')) {
              priorityId = process.env.PRIORITY_P0;
            } else if (title.includes('[P1]') || title.includes('[URGENT]')) {
              priorityId = process.env.PRIORITY_P1;
            } else if (title.includes('[P2]')) {
              priorityId = process.env.PRIORITY_P2;
            }
            
            const mutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: { singleSelectOptionId: $optionId }
                }) {
                  projectV2Item {
                    id
                  }
                }
              }
            `;
            
            await github.graphql(mutation, {
              projectId: process.env.PROJECT_ID,
              itemId: itemId,
              fieldId: process.env.PRIORITY_FIELD,
              optionId: priorityId
            });
            
            console.log(`Set priority to ${priorityId}`);
            
      - name: Set Component based on labels and content
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const itemId = '${{ needs.add-to-project.outputs.item-id }}';
            const labels = context.payload.issue?.labels || context.payload.pull_request?.labels || [];
            const body = context.payload.issue?.body || context.payload.pull_request?.body || '';
            
            let componentId = null;
            
            // Check labels for component hints (using issue type labels, not component labels)
            if (labels.some(l => l.name === 'ui' || l.name === 'ux')) {
              componentId = process.env.COMPONENT_FRONTEND;
            } else if (labels.some(l => l.name === 'api' || l.name === 'server')) {
              componentId = process.env.COMPONENT_BACKEND;
            } else if (labels.some(l => l.name === 'database' || l.name === 'db')) {
              componentId = process.env.COMPONENT_DATABASE;
            } else if (labels.some(l => l.name === 'ci' || l.name === 'cd' || l.name === 'infrastructure')) {
              componentId = process.env.COMPONENT_DEVOPS;
            }
            
            // Check body content for component mentions - extract the actual component name
            if (!componentId) {
              const componentMatch = body.match(/\*?\*?Component\*?\*?:\s*([A-Za-z\s]+)/i);
              if (componentMatch) {
                const componentName = componentMatch[1].trim();
                
                // Query for the component field and its options
                const query = `
                  query($projectId: ID!) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        field(name: "Component") {
                          ... on ProjectV2SingleSelectField {
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                
                const result = await github.graphql(query, {
                  projectId: process.env.PROJECT_ID
                });
                
                // Find the matching component option (case-insensitive)
                const options = result.node.field.options || [];
                const matchedOption = options.find(opt => 
                  opt.name.toLowerCase() === componentName.toLowerCase()
                );
                
                if (matchedOption) {
                  componentId = matchedOption.id;
                  console.log(`Found component: ${matchedOption.name} (${matchedOption.id})`);
                }
              }
            }
            
            if (componentId) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;
              
              await github.graphql(mutation, {
                projectId: process.env.PROJECT_ID,
                itemId: itemId,
                fieldId: process.env.COMPONENT_FIELD,
                optionId: componentId
              });
              
              console.log(`Set component to ${componentId}`);
            }
            
      - name: Set Initial Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const itemId = '${{ needs.add-to-project.outputs.item-id }}';
            
            // Default to TODO for new items
            let statusId = process.env.STATUS_TODO;
            
            // If it's a PR, set to In Progress
            if (context.payload.pull_request) {
              statusId = process.env.STATUS_IN_PROGRESS;
            }
            
            const mutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: { singleSelectOptionId: $optionId }
                }) {
                  projectV2Item {
                    id
                  }
                }
              }
            `;
            
            await github.graphql(mutation, {
              projectId: process.env.PROJECT_ID,
              itemId: itemId,
              fieldId: process.env.STATUS_FIELD,
              optionId: statusId
            });
            
            console.log(`Set status to ${statusId}`);
            
      - name: Set Sprint Fields and Iteration
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const itemId = '${{ needs.add-to-project.outputs.item-id }}';
            const issue = context.payload.issue;
            if (!issue) return; // Skip for PRs
            
            // Parse Sprint metadata from issue body
            const body = issue.body || '';
            
            // Get current date to determine iteration
            const currentDate = new Date().toISOString().split('T')[0];
            
            // Query for available iterations and fields
            const query = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 30) {
                      nodes {
                        ... on ProjectV2Field {
                          id
                          name
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                        ... on ProjectV2IterationField {
                          id
                          name
                          configuration {
                            iterations {
                              id
                              title
                              startDate
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const result = await github.graphql(query, {
              projectId: process.env.PROJECT_ID
            });
            
            const fields = result.node.fields.nodes;
            
            // Find Sprint fields
            const sprintPointsField = fields.find(f => f.name === 'Sprint Points');
            const sprintStatusField = fields.find(f => f.name === 'Sprint Status');
            const sprintGoalField = fields.find(f => f.name === 'Sprint Goal');
            const iterationField = fields.find(f => f.name === 'Iteration');
            const complexityField = fields.find(f => f.name === 'Complexity');
            const createdDateField = fields.find(f => f.name === 'Created Date');
            const dueDateField = fields.find(f => f.name === 'Due Date');
            
            // Parse sprint points from body (default 3)
            let sprintPoints = 3;
            const pointsMatch = body.match(/\*?\*?Points?\*?\*?:\s*(\d+)/i);
            if (pointsMatch) sprintPoints = parseInt(pointsMatch[1]);
            
            // Set Sprint Points
            if (sprintPointsField) {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { number: $value }
                  }) {
                    projectV2Item { id }
                  }
                }
              `, {
                projectId: process.env.PROJECT_ID,
                itemId: itemId,
                fieldId: sprintPointsField.id,
                value: sprintPoints
              });
            }
            
            // Set Sprint Status to "Not Started"
            if (sprintStatusField) {
              const notStarted = sprintStatusField.options.find(o => o.name === 'Not Started');
              if (notStarted) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: sprintStatusField.id,
                  optionId: notStarted.id
                });
              }
            }
            
            // Set Complexity based on issue content
            if (complexityField) {
              let complexityName = 'M'; // default
              
              // Check for complexity/size in body
              const complexityMatch = body.match(/\*?\*?(?:Complexity|Size)\*?\*?:\s*(XS|S|M|L|XL)/i);
              if (complexityMatch) complexityName = complexityMatch[1].toUpperCase();
              
              const complexity = complexityField.options.find(o => o.name === complexityName);
              if (complexity) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: complexityField.id,
                  optionId: complexity.id
                });
              }
            }
            
            // Set Sprint Goal based on issue content
            if (sprintGoalField) {
              let goalName = 'Features'; // default
              
              // Check for goal in body
              const goalMatch = body.match(/\*?\*?Goal\*?\*?:\s*(MVP|User Experience|Performance|Tech Debt|Features)/i);
              if (goalMatch) goalName = goalMatch[1];
              
              // Or infer from labels
              const labels = issue.labels || [];
              if (labels.some(l => l.name === 'performance')) goalName = 'Performance';
              else if (labels.some(l => l.name === 'tech-debt')) goalName = 'Tech Debt';
              else if (labels.some(l => l.name === 'ui' || l.name === 'ux')) goalName = 'User Experience';
              
              const goal = sprintGoalField.options.find(o => o.name === goalName);
              if (goal) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: sprintGoalField.id,
                  optionId: goal.id
                });
              }
            }
            
            // Set Iteration based on current date and priority
            if (iterationField && iterationField.configuration) {
              const iterations = iterationField.configuration.iterations;
              
              // Find current iteration
              let currentIteration = iterations.find(i => i.startDate <= currentDate);
              
              // Override based on priority
              const priorityMatch = body.match(/\*?\*?Priority\*?\*?:\s*(P[0-3])/i);
              const priority = priorityMatch ? priorityMatch[1] : 
                             issue.title.includes('[P0]') ? 'P0' : 
                             issue.title.includes('[P1]') ? 'P1' : 'P2';
              
              // P0 = current iteration, P1 = current or next, P2+ = next
              if (priority === 'P0') {
                // Use current iteration
              } else if (priority === 'P1' && iterations[1]) {
                currentIteration = iterations[1]; // next iteration
              } else if (iterations[2]) {
                currentIteration = iterations[2]; // future iteration
              }
              
              if (currentIteration) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { iterationId: $iterationId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: iterationField.id,
                  iterationId: currentIteration.id
                });
                
                console.log(`Set iteration to ${currentIteration.title}`);
              }
            }
            
            // Set Created Date to today
            if (createdDateField) {
              const today = new Date().toISOString().split('T')[0];
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { date: $date }
                  }) {
                    projectV2Item { id }
                  }
                }
              `, {
                projectId: process.env.PROJECT_ID,
                itemId: itemId,
                fieldId: createdDateField.id,
                date: today
              });
            }
            
            // Set Due Date based on iteration
            if (dueDateField && currentIteration) {
              // Calculate due date as end of iteration (start + 14 days)
              const startDate = new Date(currentIteration.startDate);
              const dueDate = new Date(startDate);
              dueDate.setDate(startDate.getDate() + 13); // 14 day sprint
              
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { date: $date }
                  }) {
                    projectV2Item { id }
                  }
                }
              `, {
                projectId: process.env.PROJECT_ID,
                itemId: itemId,
                fieldId: dueDateField.id,
                date: dueDate.toISOString().split('T')[0]
              });
            }


  update-status-on-progress:
    name: Update Status on Progress
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && github.event.action == 'assigned') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened')
    
    steps:
      - name: Move to In Progress
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            // Get the issue number
            let issueNumber;
            if (context.payload.issue) {
              issueNumber = context.payload.issue.number;
            } else if (context.payload.pull_request) {
              // Extract issue number from PR body or title
              const prBody = context.payload.pull_request.body || '';
              const prTitle = context.payload.pull_request.title || '';
              const match = (prBody + prTitle).match(/#(\d+)/);
              if (match) {
                issueNumber = match[1];
              }
            }
            
            if (!issueNumber) return;
            
            // Find the project item
            const query = `
              query {
                repository(owner: "${{ github.repository_owner }}", name: "${{ github.event.repository.name }}") {
                  issue(number: ${issueNumber}) {
                    projectItems(first: 10) {
                      nodes {
                        id
                        project {
                          id
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const result = await github.graphql(query);
            const projectItem = result.repository.issue.projectItems.nodes.find(
              item => item.project.id === process.env.PROJECT_ID
            );
            
            if (projectItem) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;
              
              await github.graphql(mutation, {
                projectId: process.env.PROJECT_ID,
                itemId: projectItem.id,
                fieldId: process.env.STATUS_FIELD,
                optionId: process.env.STATUS_IN_PROGRESS
              });
              
              console.log('Moved to In Progress');
            }

  check-unblock-on-close:
    name: Check and Unblock Related Issues
    runs-on: ubuntu-latest
    if: github.event.action == 'closed' && github.event.issue
    
    steps:
      - name: Find and unblock dependent issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const closedIssue = context.payload.issue;
            
            // Search for issues that mention being blocked by this one
            const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open "blocked by #${closedIssue.number}"`;
            
            const searchResults = await github.rest.search.issuesAndPullRequests({
              q: searchQuery
            });
            
            for (const issue of searchResults.data.items) {
              // Remove blocked label if it exists
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'blocked'
                });
              } catch (e) {
                // Label might not exist, that's ok
              }
              
              // Add a comment that it's unblocked
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `✅ **Unblocked!** Issue #${closedIssue.number} has been closed.\n\nThis issue is now ready to be worked on.`
              });
            }

  update-status-on-close:
    name: Update Status on Close
    runs-on: ubuntu-latest
    if: |
      (github.event.action == 'closed') ||
      (github.event_name == 'pull_request' && github.event.action == 'merged')
    
    steps:
      - name: Move to Done
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            // Only add issues, not pull requests
            if (!context.payload.issue) {
              console.log('Not an issue, skipping project addition');
              return;
            }
            const contentId = context.payload.issue.node_id;
            
            const query = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                          }
                          ... on PullRequest {
                            id
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const result = await github.graphql(query, {
              projectId: process.env.PROJECT_ID
            });
            
            const item = result.node.items.nodes.find(i => i.content?.id === contentId);
            
            if (item) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;
              
              await github.graphql(mutation, {
                projectId: process.env.PROJECT_ID,
                itemId: item.id,
                fieldId: process.env.STATUS_FIELD,
                optionId: process.env.STATUS_DONE
              });
              
              console.log('Moved to Done');
            }

  extract-and-set-metadata:
    name: Extract and Set Metadata from Issue Body
    runs-on: ubuntu-latest
    if: github.event.issue && github.event.action == 'opened'
    needs: add-to-project
    
    steps:
      - name: Parse and Set All Metadata Fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const itemId = '${{ needs.add-to-project.outputs.item-id }}';
            const body = context.payload.issue?.body || '';
            
            console.log('Parsing issue body for metadata...');
            
            // Parse priority from body - matches **Priority**: P0 format
            let priority = 'P3';
            const priorityMatch = body.match(/\*\*Priority\*\*:\s*(P[0-3])/i);
            if (priorityMatch) {
              priority = priorityMatch[1];
              console.log(`Parsed Priority: ${priority}`);
            }
            
            // Parse component from body - matches **Component**: Frontend format
            let component = null;
            const componentMatch = body.match(/\*\*Component\*\*:\s*([^\n\*]+)/i);
            if (componentMatch) {
              component = componentMatch[1].trim();
              // Remove any trailing asterisks or parenthetical text
              component = component.replace(/\s*\*.*$/, '').replace(/\s*\(.*\)$/, '').trim();
              console.log(`Parsed Component: ${component}`);
            }
            
            // Parse sprint points from body - matches **Points**: 13 format
            let sprintPoints = 3;
            const pointsMatch = body.match(/\*\*Points\*\*:\s*(\d+)/i);
            if (pointsMatch) {
              sprintPoints = parseInt(pointsMatch[1]);
              console.log(`Parsed Points: ${sprintPoints}`);
            }
            
            // Parse sprint goal from body - matches **Goal**: MVP format
            let sprintGoal = 'Features';
            const goalMatch = body.match(/\*\*Goal\*\*:\s*([^\n\*]+)/i);
            if (goalMatch) {
              sprintGoal = goalMatch[1].trim();
              // Remove any trailing asterisks or parenthetical text
              sprintGoal = sprintGoal.replace(/\s*\*.*$/, '').replace(/\s*\(.*\)$/, '').trim();
              console.log(`Parsed Goal: ${sprintGoal}`);
            }
            
            // Parse complexity from body - matches **Complexity**: XL format
            let complexity = 'M';
            const complexityMatch = body.match(/\*\*Complexity\*\*:\s*(XS|S|M|L|XL)/i);
            if (complexityMatch) {
              complexity = complexityMatch[1].toUpperCase();
              console.log(`Parsed Complexity: ${complexity}`);
            }
            
            // Parse milestone from body - matches **Milestone**: v0.1.0 format
            let milestone = null;
            const milestoneMatch = body.match(/\*\*Milestone\*\*:\s*([^\n\*]+)/i);
            if (milestoneMatch) {
              milestone = milestoneMatch[1].trim();
              // Remove any trailing text after dash
              if (milestone.includes(' - ')) {
                milestone = milestone.split(' - ')[0].trim();
              }
              console.log(`Parsed Milestone: ${milestone}`);
            }
            
            // Default milestone based on priority if not specified (feature-based, not version-based)
            if (!milestone) {
              if (priority === 'P0') milestone = 'Critical Features';
              else if (priority === 'P1') milestone = 'Core Features';
              else if (priority === 'P2') milestone = 'Enhancements';
              else milestone = 'Backlog';
              console.log(`Using default milestone based on priority: ${milestone}`);
            }
            
            // Query for all project fields and their options
            const query = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 30) {
                      nodes {
                        ... on ProjectV2Field {
                          id
                          name
                          dataType
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                        ... on ProjectV2IterationField {
                          id
                          name
                          configuration {
                            iterations {
                              id
                              title
                              startDate
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const result = await github.graphql(query, {
              projectId: process.env.PROJECT_ID
            });
            
            const fields = result.node.fields.nodes;
            
            // Set Priority field
            const priorityField = fields.find(f => f.name === 'Priority');
            if (priorityField && priority) {
              const priorityOption = priorityField.options?.find(o => o.name === priority);
              if (priorityOption) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: priorityField.id,
                  optionId: priorityOption.id
                });
                console.log(`Set Priority to ${priority}`);
              }
            }
            
            // Set Component field - simple case-insensitive matching only (plumbing operation)
            const componentField = fields.find(f => f.name === 'Component');
            if (componentField && component) {
              // Simple direct match only - no intelligent mapping
              const componentOption = componentField.options?.find(o => 
                o.name.toLowerCase() === component.toLowerCase()
              );
              
              if (componentOption) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: componentField.id,
                  optionId: componentOption.id
                });
                console.log(`Set Component to ${componentOption.name}`);
              } else {
                console.log(`Component '${component}' not found - no fallback logic (plumbing only)`);
              }
            }
            
            // Set Sprint Points field
            const sprintPointsField = fields.find(f => f.name === 'Sprint Points');
            if (sprintPointsField) {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { number: $value }
                  }) {
                    projectV2Item { id }
                  }
                }
              `, {
                projectId: process.env.PROJECT_ID,
                itemId: itemId,
                fieldId: sprintPointsField.id,
                value: sprintPoints
              });
              console.log(`Set Sprint Points to ${sprintPoints}`);
            }
            
            // Set Sprint Goal field
            const sprintGoalField = fields.find(f => f.name === 'Sprint Goal');
            if (sprintGoalField && sprintGoal) {
              const goalOption = sprintGoalField.options?.find(o => o.name === sprintGoal);
              if (goalOption) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: sprintGoalField.id,
                  optionId: goalOption.id
                });
                console.log(`Set Sprint Goal to ${sprintGoal}`);
              }
            }
            
            // Set Complexity field
            const complexityField = fields.find(f => f.name === 'Complexity');
            if (complexityField && complexity) {
              const complexityOption = complexityField.options?.find(o => o.name === complexity);
              if (complexityOption) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }
                `, {
                  projectId: process.env.PROJECT_ID,
                  itemId: itemId,
                  fieldId: complexityField.id,
                  optionId: complexityOption.id
                });
                console.log(`Set Complexity to ${complexity}`);
              }
            }
            
            // Assign milestone to the issue
            if (milestone) {
              try {
                // Get all milestones
                const milestones = await github.rest.issues.listMilestones({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                // Find matching milestone (exact match or starts with)
                const matchingMilestone = milestones.data.find(m => 
                  m.title === milestone || 
                  m.title.startsWith(milestone) ||
                  m.title === `${milestone} - MVP` ||
                  m.title === `${milestone} - Enhanced Features` ||
                  m.title === `${milestone} - Performance & Polish` ||
                  m.title === `${milestone} - Initial Release`
                );
                
                if (matchingMilestone) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.issue.number,
                    milestone: matchingMilestone.number
                  });
                  console.log(`Set Milestone to ${matchingMilestone.title}`);
                } else {
                  console.log(`Milestone '${milestone}' not found in available milestones`);
                }
              } catch (error) {
                console.log('Could not set milestone:', error.message);
              }
            }
            
            // Check for blocking relationships in issue body
            const blockedByMatch = body.match(/\*\*Blocked by\*\*:\s*([^\\n]+)/i);
            if (blockedByMatch) {
              const blockedByText = blockedByMatch[1].trim();
              const issueNumbers = blockedByText.match(/#(\d+)/g);
              
              if (issueNumbers) {
                // Add blocked label
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  labels: ['blocked']
                });
                
                // Add blocking comment
                const blockers = issueNumbers.join(', ');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  body: `⚠️ **This issue is blocked**\\n\\nBlocked by: ${blockers}\\n\\nWork on the blocking issues first before starting this one.`
                });
                
                console.log(`Issue blocked by: ${blockers}`);
              }
            }
            
            // Assign user and add standard engagement comment
            try {
              // Assign the issue creator (simple plumbing operation)
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                assignees: [context.payload.issue.user.login]
              });
              console.log('Assigned issue creator');
              
              // Add standard issue comment (plumbing only, no intelligence)
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: '✅ **Issue processed** - Added to project board and assigned.\n\n**Next Steps:**\n- Review the generated branch and draft PR\n- Agent assignment will be handled by Claude Code orchestration system'
              });
              console.log('Added standard issue comment');
              
            } catch (error) {
              console.log('Error with issue assignment:', error.message);
            }