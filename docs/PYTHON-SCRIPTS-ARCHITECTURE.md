# Python Scripts Architecture for Slash Commands

## Key Discoveries from Advanced Slash Command Patterns

### 1. The Problem with Current Commands
Our current slash commands have **too much inline bash logic**. They're trying to be smart instead of delegating to proper scripts or agents.

### 2. The Better Pattern (from screenshot)

```markdown
---
allowed-tools: Task(*), Read(*), Write(*)
---

# Command Name

## Load Context Files
- @file1.md
- @file2.json
- @directory/file3.ts

## <variable_name>
This is a reusable prompt or data that gets passed to agents
</variable_name>

## Your Task
1. Read the @ files first to load context
2. Use Task tool with agents and the <variable_name> prompt
3. Simple execution, no complex logic
```

### 3. Python Scripts for Complex Logic

Instead of complex bash in slash commands, use Python scripts:

```python
#!/usr/bin/env python3
# scripts/commands/smart-operation.py

import json
import subprocess
import sys

def analyze_context():
    """Complex analysis logic here"""
    pass

def orchestrate_agents():
    """Agent orchestration logic"""
    pass

def main():
    # All the complex logic lives here
    # Not in the slash command
    pass
```

Then the slash command becomes simple:

```markdown
---
allowed-tools: Bash(*), Task(*)
---

# Smart Operation

Run: !python3 scripts/commands/smart-operation.py $ARGUMENTS
```

## Architecture Benefits

### 1. Separation of Concerns
- **Slash Commands**: Simple routing and file loading
- **Python Scripts**: Complex logic and decision making
- **Agents**: Specialized tasks via Task tool

### 2. Parallel Execution
Instead of sequential bash commands:
```bash
# BAD - Sequential
gh issue list
gh issue view 123
gh pr create
```

Use Python to prepare parallel agent tasks:
```python
# GOOD - Parallel
tasks = [
    {"agent": "analyzer", "prompt": "..."},
    {"agent": "architect", "prompt": "..."},
    {"agent": "tester", "prompt": "..."}
]
# All run simultaneously via Task tool
```

### 3. Proper Context Loading

The `@` pattern ensures files are loaded into context:
```markdown
## Context Files
- @README.md
- @package.json
- @src/index.ts
```

This loads them BEFORE any logic runs, ensuring agents have full context.

## Implementation Examples

### Example 1: Issue Creation with Context

**Python Script** (`scripts/commands/create-issue.py`):
- Analyzes title for complexity
- Determines agent assignment
- Creates issue via GitHub API
- Returns structured data

**Slash Command** (`create-issue.md`):
```markdown
## Load Project Context
- @CLAUDE.md
- @package.json

## Your Task
Run: !python3 scripts/commands/create-issue.py "$ARGUMENTS"
If Copilot-eligible: Use mcp__github__assign_copilot_to_issue
```

### Example 2: Multi-Agent Orchestration

**Python Script** (`scripts/commands/multi-agent-task.py`):
- Analyzes task requirements
- Identifies needed agents
- Generates parallel task definitions
- Returns orchestration plan

**Slash Command** (`multi-agent.md`):
```markdown
## <task_prompts>
Generated by Python script
</task_prompts>

## Your Task
Run multiple Task tools in parallel with <task_prompts>
```

## Migration Strategy

### Phase 1: Create Python Scripts
1. `create-issue.py` - Issue creation logic
2. `work-on-issue.py` - Branch/PR setup
3. `multi-agent-task.py` - Agent orchestration
4. `project-analysis.py` - Codebase analysis

### Phase 2: Simplify Slash Commands
1. Remove inline bash logic
2. Add @ file loading patterns
3. Use Python scripts for logic
4. Add Task tool for agents

### Phase 3: Test & Iterate
1. Test parameter passing
2. Verify parallel execution
3. Measure performance gains
4. Refine patterns

## Best Practices

### DO:
- ✅ Use Python for complex logic
- ✅ Load context files with @
- ✅ Run agents in parallel via Task
- ✅ Keep slash commands simple
- ✅ Use variables like <prompt> for reusability

### DON'T:
- ❌ Put complex bash in slash commands
- ❌ Run sequential operations when parallel is possible
- ❌ Make decisions in slash commands
- ❌ Use template placeholders like `<path>` in commands
- ❌ Forget to load context before agent tasks

## Next Steps

1. **Refactor existing commands** to use Python scripts
2. **Create agent orchestration library** in Python
3. **Test parallel execution** performance
4. **Document patterns** for team use
5. **Build command generator** to create new commands easily